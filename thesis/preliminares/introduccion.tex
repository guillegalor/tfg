% !TeX root = ../libro.tex
% !TeX encoding = utf8
%
%*******************************************************
% Introducción
%*******************************************************

% \manualmark
% \markboth{\textsc{Introducción}}{\textsc{Introducción}}

\chapter{Introducción}

Se puede establecer el inicio de la Teoría de Códigos Correctores de Errores en el trabajo pionero~\cite{Shannon_1948} de C. Shannon, en el que se establecen los elementos básicos de la comunicación, se desarrolla el concepto de redundancia y cómo puede usarse para detectar y corregir errores al transmitir información a través de un canal con ruido. Un paso esencial en dicha teoría fue la introducción de estructuras algebraicas en la gestión de la redundancia. De esta forma surgen los códigos lineales que, matemáticamente, pueden ser vistos como subespacios vectoriales de $\mathbb{F}_q^n$, donde $\mathbb{F}_q$ es el cuerpo finito de $q$ elementos, junto con una métrica, usualmente la métrica de Hamming. La linealidad permite sistematizar la construcción de la redundancia, lo que permite construir codificadores de forma eficiente. Un problema mucho más complicado es el de eliminar los errores introducidos mediante la decodificación. La técnica general más estudiada es la decodificación por síndrome, que requiere manejar tablas cuyo tamaño para códigos con parámetros no excesivamente grandes puede ser inmenso. Para salvar esta dificultad, se enriquece la estructura algebraica de los códigos lineales. Entre los más estudiados están los códigos cíclicos, que pueden ser descritos como ideales del anillo cociente $\mathbb{F}_q[x]/\langle x^n -1 \rangle$. La descomposición completa de $x^n-1$ en la extensión apropiada de \(\mathbb{F}_q\) permite, mediante el cálculo de las raíces, establecer cotas para la distancia del código. En este sentido podemos destacar los códigos BCH, introducidos en~\cite{hocquenghem1959codes,bose1960class,bose1960further}, y dentro de ellos los códigos de Reed--Solomon,~\cite{ReedSolomon_1960}. Estos códigos pueden decodificarse de forma eficiente mediante varios algoritmos, entre los que destacamos el algoritmo de Sugiyama~\cite{Sugiyama_1975}, basado en el algoritmo extendido de Euclides.

El innegable éxito de la estructura polinomial en el diseño de códigos con buenos parámetros y sus correspondientes algoritmos de decodificación sugirió la idea de utilizar polinomios sesgados (skew polynomials) introducidos por O. Ore en~\cite{Ore_1933}. Estos polinomios no conmutativos mantienen muchas de las propiedades de los polinomios conmutativos, como la existencia de algoritmos de división, en este caso a izquierda y derecha, de los que se deriva el cálculo de máximos común divisores y mínimos común múltiplos laterales mediante los correspondientes algoritmos extendidos de Euclides a ambos lados. Por el contrario la evaluación de polinomios sí es esencialmente diferente, tal y como se puede observar en~\cite{lam_vandermonde_1988,Leroy_1995}. En 2007, Boucher, Geiselmann y Ulmer introducen en~\cite{boucher2007skew} los \emph{skew cyclic codes} (códigos cíclicos sesgados) mediante los polinomios anteriormente descritos con coeficientes en cuerpos finitos, y desarrollan junto con otros autores algunas propiedades de los mismos en~\cite{boucher2009codes,boucher2009coding,chaussade2009skew}, incluyendo una primera adaptación al caso sesgado del algoritmo de Sugiyama.

En 2016, Gómez-Torrecillas, Lobillo y Navarro extienden en~\cite{gomez-torrecillas_new_2016} la noción de ciclicidad sesgada a cuerpos de funciones racionales sobre cuerpos finitos, lo que cubre el caso de los llamados códigos convolucionales, y un año más tarde publican en~\cite{gomez-torrecillas_sugiyama_2016}, una versión del algoritmo de Sugiyama para códigos sesgados de Reed-Solomon (skew RS), versión adaptada en este trabajo para cubrir cualquier extensión cíclica de cuerpos.

Dichos algoritmos han sido implementados en SageMath como parte de este Trabajo de Fin de Grado. Citando~\cite{sagemath}, \emph{``SageMath is a free open-source mathematics software system licensed under the GPL. It builds on top of many existing open-source packages: NumPy, SciPy, matplotlib, Sympy, Maxima, GAP, FLINT, R and many more. Access their combined power through a common, Python-based language or directly via interfaces or wrappers.''} (SageMath es un software matemático libre de código abierto publicado bajo licencia GPL. Está construido sobre muchos paquetes de código abierto existentes: NumPy, SciPy, matplotlib, Sympy, Maxima, GAP, FLINT, R y muchos otros. Accede a su potencia combinada a través de un lenguaje común basado en Python o directamente a través de interfaces o empaquetadores.)

\endinput
